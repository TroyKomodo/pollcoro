= pollcoro
:toc:
:toc-placement!:
:source-highlighter: highlight.js

A header-only C++17 coroutine-ts library using *polling* instead of the traditional resume-based approach.

Unlike most C++ coroutine libraries that rely on continuation-passing and resume callbacks, pollcoro uses an explicit polling model inspired by Rust's `Future` trait. Awaitables expose an `poll()` method that returns either `ready` or `pending`, giving you fine-grained control over execution.

WARNING: This library is experimental and not yet production ready.

toc::[]

== Features

* *Poll-based design* — explicit control over when and how coroutines make progress
* *Header-only* — drop into your project with no compilation required
* *Async generators* — `generator<T>` with `co_yield`, `co_await`, and yield-from support
* *C++20 modules* — optional module support for faster builds
* *PCH support* — precompiled header target for improved compile times
* *CMake integration* — modern CMake with `find_package` support

== Polling vs Resume-Based Coroutines

Most C++ coroutine libraries use a *resume-based* model where an awaitable stores a continuation (the `coroutine_handle`) and calls `resume()` when ready. This creates implicit control flow — the awaitable decides when and where execution continues.

[source,cpp]
----
// Resume-based: awaitable controls execution
struct resume_awaitable {
    std::coroutine_handle<> handle_;
    
    void await_suspend(std::coroutine_handle<> h) {
        handle_ = h;
        // Later, some callback does: handle_.resume();
    }
};
----

pollcoro uses a *poll-based* model inspired by Rust's `Future` trait. Instead of giving away control, the executor repeatedly polls awaitables, which return `ready` or `pending`:

[source,cpp]
----
// Poll-based: executor controls execution
struct poll_awaitable {
    pollcoro::awaitable_state<int> poll(const pollcoro::waker& w) {
        if (is_ready()) {
            return pollcoro::awaitable_state<int>::ready(result_);
        }
        waker_ = w;  // Store waker to signal "poll me again"
        return pollcoro::awaitable_state<int>::pending();
    }
};
----

=== Why Polling?

[cols="1,2,2"]
|===
| Aspect | Resume-Based | Poll-Based

| *Control*
| Awaitable resumes coroutine directly
| Executor decides when to poll

| *Thread Safety*
| Resume can happen on any thread
| All polling happens on executor's thread

| *Cancellation*
| Requires explicit cancellation tokens
| Just stop polling — no cleanup needed

| *Composition*
| Complex with multiple continuations
| Natural — poll children, aggregate results

| *Debugging*
| Stack traces show resume site
| Stack traces show poll call chain
|===

The polling model trades some efficiency (extra poll calls) for predictability and simpler reasoning about control flow.

== Installation

=== CPM.cmake

[source,cmake]
----
CPMAddPackage("gh:troykomodo/pollcoro#main")
----

== Quick Start

[source,cpp]
----
#include <pollcoro/task.hpp>
#include <pollcoro/block_on.hpp>
#include <iostream>

pollcoro::task<int> async_add(int a, int b) {
    co_return a + b;
}

pollcoro::task<int> compute() {
    int x = co_await async_add(10, 20);
    int y = co_await async_add(x, 5);
    co_return y;
}

int main() {
    int result = pollcoro::block_on(compute());
    std::cout << "Result: " << result << std::endl;  // Result: 35
}
----

== Examples

The `examples/` directory contains several demonstrations:

* link:examples/fib.cc[fib.cc] — Concurrent Fibonacci using `wait_all` to compute both branches in parallel
* link:examples/generator.cc[generator.cc] — Async generators with `co_yield`, `co_await`, and yield-from
* link:examples/cc17.cc[cc17.cc] — Basic coroutine usage in C++17
* link:examples/thread_callback.cc[thread_callback.cc] — Bridging threaded callbacks into coroutines using `single_event`
* link:examples/modules.cc[modules.cc] — Using pollcoro with C++20 module imports
* link:examples/c_interop.c[c_interop.c] / link:examples/c_interop_impl.cc[c_interop_impl.cc] — Exposing pollcoro tasks through a C API
* link:examples/exceptions.cc[exceptions.cc] — Exception handling and propagation in coroutines
* link:examples/timer_sleep.cc[timer_sleep.cc] — Using `sleep_until` with a custom timer implementation
* link:examples/cxx_cppcoro_interop.cc[cxx_cppcoro_interop.cc] — Interoperability with cppcoro (resume-based library)

== Core Concepts

=== The Polling Model

In pollcoro, every awaitable implements `poll(waker& w)` which returns a `awaitable_state<T>`:

[source,cpp]
----
struct my_awaitable {
    pollcoro::awaitable_state<int> poll(const pollcoro::waker& w) {
        if (/* ready */) {
            return pollcoro::awaitable_state<int>::ready(42);
        }
        // Store waker to notify when ready
        stored_waker_ = w;
        return pollcoro::awaitable_state<int>::pending();
    }
};
----

The `waker` is a callback that signals "poll me again" — call it when your awaitable becomes ready.

=== `pollcoro::awaitable` Concept

Any type satisfying this concept can be `co_await`ed inside a `task`:

[source,cpp]
----
template<typename T>
concept awaitable = requires(T t, const waker& w) {
    { t.poll(w) } -> /* returns awaitable_state<U> */;
};
----

=== `pollcoro::gen_awaitable` Concept

Any type satisfying this concept can be used with `co_yield` inside a `generator` (yield-from):

[source,cpp]
----
template<typename T>
concept gen_awaitable = requires(T t, const waker& w) {
    { t.poll_next(w) } -> /* returns gen_awaitable_state<U> */;
};
----

The `generator<T>` type itself satisfies `gen_awaitable`, enabling yield-from composition.

=== Exception Handling

Exceptions in pollcoro work just like normal C++ exceptions. They bubble up through `co_await` the same way they would through regular function calls. If nothing catches them, they propagate all the way up to the poll site (e.g., `block_on`).

[source,cpp]
----
pollcoro::task<int> might_throw(int value) {
    if (value < 0) {
        throw std::runtime_error("negative value");
    }
    co_return value * 2;
}

pollcoro::task<int> caller() {
    try {
        co_return co_await might_throw(-5);  // Exception caught here
    } catch (const std::runtime_error& e) {
        std::cout << "Caught: " << e.what() << std::endl;
        co_return 0;
    }
}
----

If an exception isn't caught, it continues bubbling up through each `co_await` until it reaches `block_on`:

[source,cpp]
----
pollcoro::task<int> inner() {
    throw std::runtime_error("something went wrong");
    co_return 42;
}

pollcoro::task<int> outer() {
    co_return co_await inner();  // Exception passes through
}

int main() {
    try {
        pollcoro::block_on(outer());  // Exception caught here
    } catch (const std::runtime_error& e) {
        std::cerr << "Uncaught exception: " << e.what() << std::endl;
    }
}
----

== API Reference

=== `pollcoro::task<T>`

The primary coroutine type. Lazy — doesn't run until polled.

[source,cpp]
----
#include <pollcoro/task.hpp>

pollcoro::task<int> fetch_value() {
    co_return 42;
}

pollcoro::task<> do_work() {  // void task
    co_await fetch_value();
    co_return;
}
----

For advanced use cases, you can extract the underlying coroutine handle:

[source,cpp]
----
auto task = fetch_value();
auto handle = std::move(task).release();  // task is now empty
// Work directly with the coroutine handle
handle.destroy();  // You're responsible for cleanup
----

=== `pollcoro::generator<T>`

An async generator that produces a sequence of values. Supports `co_yield` for values, `co_await` for async operations, and yield-from for delegating to other generators.

[source,cpp]
----
#include <pollcoro/generator.hpp>

// Simple generator
pollcoro::generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield b;
        auto tmp = a;
        a = b;
        b += tmp;
    }
}

// Generator with async operations
pollcoro::generator<int> async_counter(int count) {
    for (int i = 0; i < count; ++i) {
        co_await pollcoro::yield();  // Async work
        co_yield i;
    }
}

// Yield-from: delegate to another generator
pollcoro::generator<int> range(int start, int end) {
    for (int i = start; i < end; ++i) {
        co_yield i;
    }
}

pollcoro::generator<int> combined() {
    co_yield 100;              // Single value
    co_yield range(0, 3);      // Yield from generator: 0, 1, 2
    co_yield 200;
}
----

=== `pollcoro::gen_next`

Convert a generator into an awaitable that returns `std::optional<T>`. Returns `std::nullopt` when the generator is exhausted.

[source,cpp]
----
#include <pollcoro/gen_next.hpp>

pollcoro::task<> consume_generator() {
    auto gen = fibonacci();
    while (auto value = co_await pollcoro::gen_next(gen)) {
        std::cout << *value << " ";
        if (*value > 100) break;
    }
}
----

=== `pollcoro::pending`

An awaitable that is always pending.

[source,cpp]
----
#include <pollcoro/pending.hpp>

co_await pollcoro::pending(); // will never be ready
----

=== `pollcoro::ready`

An awaitable that is always ready.

[source,cpp]
----
#include <pollcoro/ready.hpp>

co_await pollcoro::ready(42); // will instantly return 42
----

=== `pollcoro::gen`

Lightweight helpers to create generator-like awaitables from iterators or containers. Useful for yield-from with existing collections.

[source,cpp]
----
#include <pollcoro/gen.hpp>

// From iterator pair
std::vector<int> vec = {1, 2, 3};
co_yield pollcoro::gen(vec.begin(), vec.end());

// From range/container
co_yield pollcoro::gen(std::array{4, 5, 6});
co_yield pollcoro::gen(vec);
----

=== `pollcoro::gen_awaitable_state<T>`

The return type of `poll_next()` for generators. Represents ready (with value), pending, or done states.

[source,cpp]
----
#include <pollcoro/gen_awaitable.hpp>

// Creating states
auto ready = pollcoro::gen_awaitable_state<int>::ready(42);
auto pending = pollcoro::gen_awaitable_state<int>::pending();
auto done = pollcoro::gen_awaitable_state<int>::done();

// Checking state
if (state.is_ready()) {
    int value = state.take_result();
} else if (state.is_done()) {
    // Generator exhausted
}

// Mapping results
auto mapped = std::move(state).map([](int n) { return n * 2; });
----

=== `pollcoro::block_on`

Synchronously runs an awaitable to completion, blocking the current thread.

[source,cpp]
----
#include <pollcoro/block_on.hpp>

int result = pollcoro::block_on(my_async_task());
----

=== `pollcoro::sleep_for` / `pollcoro::sleep_until`

Sleep for a specified duration or until a deadline. Requires a timer type that satisfies the `timer` concept.

[source,cpp]
----
#include <pollcoro/sleep.hpp>

// Timer concept requirements:
template<typename Timer>
concept timer = requires(Timer timer) {
    typename Timer::duration;
    typename Timer::time_point;
    { timer.now() } -> std::same_as<typename Timer::time_point>;
    { timer.register_callback(deadline, callback) } -> std::same_as<void>;
};
----

Example timer implementation:

[source,cpp]
----
template<typename Clock = std::chrono::steady_clock>
struct my_timer {
    using duration = typename Clock::duration;
    using time_point = typename Clock::time_point;

    time_point now() const {
        return Clock::now();
    }

    void register_callback(const time_point& deadline, std::function<void()> callback) {
        // Use a thread pool or other efficient scheduling mechanism
        std::thread([deadline, callback] {
            std::this_thread::sleep_until(deadline);
            callback();
        }).detach();
    }
};
----

Usage:

[source,cpp]
----
// Sleep for a duration
co_await pollcoro::sleep_for<my_timer<>>(std::chrono::seconds(1));

// Sleep until a deadline
co_await pollcoro::sleep_until<my_timer<>>(
    std::chrono::steady_clock::now() + std::chrono::seconds(5)
);

// Pass a timer instance directly
my_timer<> timer;
co_await pollcoro::sleep_for(std::chrono::seconds(1), std::move(timer));
co_await pollcoro::sleep_until(deadline, std::move(timer));
----

=== `pollcoro::wait_all`

Wait for multiple awaitables to complete. Returns a tuple of results (void results are filtered out).

[source,cpp]
----
#include <pollcoro/wait_all.hpp>

// Variadic form
auto [a, b, c] = co_await pollcoro::wait_all(
    task_returning_int(),
    task_returning_string(),
    task_returning_double()
);

// Iterator form (all same type)
std::vector<pollcoro::task<int>> tasks = /* ... */;
std::vector<int> results = co_await pollcoro::wait_all(tasks);
----

=== `pollcoro::wait_first`

Wait for the first awaitable to complete. Returns the result and the index of the winner.

[source,cpp]
----
#include <pollcoro/wait_first.hpp>

// Variadic form
auto [result, index] = co_await pollcoro::wait_first(task_a(), task_b(), task_c());

// Iterator form
std::vector<pollcoro::task<int>> tasks = /* ... */;
auto [result, index] = co_await pollcoro::wait_first(tasks);
----

=== `pollcoro::single_event<T>`

A one-shot event for bridging external code (threads, callbacks) into the coroutine world.

[source,cpp]
----
#include <pollcoro/single_event.hpp>

pollcoro::task<int> wait_for_callback() {
    auto [awaitable, setter] = pollcoro::single_event<int>();
    
    // Pass setter to some external callback system
    register_callback([setter = std::move(setter)](int value) mutable {
        setter.set(value);
    });
    
    co_return co_await awaitable;
}

// For void events:
auto [awaitable, setter] = pollcoro::single_event<void>();
setter.set();  // no argument needed
----

=== `pollcoro::map`

Transform the result of an awaitable.

[source,cpp]
----
#include <pollcoro/map.hpp>

// Function form
auto doubled = co_await pollcoro::map(get_number(), [](auto n) { return n * 2; });

// Pipe syntax
auto doubled = co_await (
    get_number() | 
        pollcoro::map([](auto n) {
            return n * 2;
        })
);
----

=== `pollcoro::ref`

Create a reference wrapper around an awaitable (useful when you can't move).

[source,cpp]
----
#include <pollcoro/ref.hpp>

pollcoro::task<int> my_task = /* ... */;
co_await pollcoro::ref(my_task);  // polls my_task without moving it
----

=== `pollcoro::generic`

Type-erased awaitable wrapper. Useful when you need to store awaitables of different types in a container or return different awaitable types from a function.

[source,cpp]
----
#include <pollcoro/generic.hpp>

// Wrap any awaitable into a type-erased container
pollcoro::generic_awaitable<int> wrapped = pollcoro::generic(some_task());

// Store different awaitable types uniformly
std::vector<pollcoro::generic_awaitable<int>> tasks;
tasks.push_back(pollcoro::generic(task_a()));
tasks.push_back(pollcoro::generic(task_b()));

// Can be awaited like any other awaitable
int result = co_await wrapped;
----

=== `pollcoro::yield`

Yield control back to the executor for a specified number of polls.

[source,cpp]
----
#include <pollcoro/yield.hpp>

co_await pollcoro::yield();     // yield once
co_await pollcoro::yield(3);    // yield 3 times
----

=== `pollcoro::awaitable_state<T>`

The return type of `poll()`. Represents either a ready result or pending state.

[source,cpp]
----
#include <pollcoro/awaitable_state.hpp>

// Creating states
auto ready = pollcoro::awaitable_state<int>::ready(42);
auto pending = pollcoro::awaitable_state<int>::pending();

// Checking state
if (state.is_ready()) {
    int value = state.take_result();
}

// Mapping results
auto mapped = std::move(state).map([](int n) { return n * 2; });
----

=== `pollcoro::waker`

A callback that signals readiness. Store it and invoke when your awaitable becomes ready.

[source,cpp]
----
#include <pollcoro/waker.hpp>

class my_awaitable {
    pollcoro::waker stored_waker_;
    
public:
    pollcoro::awaitable_state<void> poll(const pollcoro::waker& w) {
        if (is_ready()) {
            return pollcoro::awaitable_state<void>::ready();
        }
        stored_waker_ = w;
        return pollcoro::awaitable_state<void>::pending();
    }
    
    void signal_ready() {
        stored_waker_.wake();
    }
};
----

You can create your own waker types by implementing the `wake` method.

[source,cpp]
----
class my_waker_t {
    // Wake the waker with ownership transfer
    void wake() {
        // implementation
    }
}

auto my_waker = my_waker_t();
auto some_task = /* ... */;

auto result = some_task.poll(pollcoro::waker(my_waker));
// do something with the result

----

==== Waker Lifetimes

A `waker` is a lightweight handle (function pointer + data pointer) — it doesn't own the underlying wake mechanism. The executor owns the actual wake implementation and passes a waker to your awaitable on each poll.

The executor must keep its waker valid until the awaitable has completed or been canceled (i.e., until the awaitable's destructor returns). This ensures the awaitable can safely call the waker during cleanup if needed.

When an awaitable stores a waker to call later, the awaitable is responsible for ensuring the waker isn't called after the awaitable is canceled. This matters when external code (another thread, a callback) might try to trigger a wake after the awaitable is gone.

The `single_event` implementation demonstrates a safe pattern: a `shared_ptr` connects the awaitable and the setter. When the awaitable is destroyed, it clears the stored waker. If another thread later calls `setter.set()`, it finds an empty waker and does nothing.

[source,cpp]
----
// Safe pattern: clear waker on destruction
~my_awaitable() {
    std::lock_guard lock(shared_->mutex);
    shared_->waker = pollcoro::waker();  // Clear to prevent stale calls
}
----

== Build Options

[cols="1,1,3"]
|===
| Option | Default | Description

| `POLLCORO_INSTALL`
| `${PROJECT_IS_TOP_LEVEL}`
| Generate install targets

| `POLLCORO_PCH`
| `ON`
| Enable precompiled headers target

| `POLLCORO_MODULES`
| `ON`
| Enable C++20 modules support

| `POLLCORO_TESTS`
| `${PROJECT_IS_TOP_LEVEL}`
| Build test suite

| `POLLCORO_EXAMPLES`
| `${PROJECT_IS_TOP_LEVEL}`
| Build example programs
|===

=== Using PCH

Link against `pollcoro::pch` for faster compilation:

[source,cmake]
----
target_link_libraries(your_target PRIVATE pollcoro::pch)
----

=== Using Modules

Link against `pollcoro::module` and import in your code:

[source,cpp]
----
import pollcoro;
----

Requires CMake 3.28+ and a supporting compiler (GCC 14+, Clang 16+, MSVC 19.34+).

== Writing Custom Awaitables

Any type can be awaited if it implements `on_poll`:

[source,cpp]
----
class timer_awaitable {
    std::chrono::steady_clock::time_point deadline_;
    struct shared {
        std::mutex mutex;
        pollcoro::waker waker;
    };
    std::shared_ptr<shared> shared_;
    bool started_ = false;

    void reset() {
        if (shared_ && started_) {
            std::lock_guard lock(shared_->mutex);
            shared_->waker = pollcoro::waker();
        }
        shared_ = nullptr;
        started_ = false;
    }
    
public:
    explicit timer_awaitable(std::chrono::milliseconds duration)
        : deadline_(std::chrono::steady_clock::now() + duration),
         shared_(std::make_shared<shared>()) {}

    ~timer_awaitable() {
        reset();
    }

    timer_awaitable(const timer_awaitable& other) = delete;
    timer_awaitable& operator=(const timer_awaitable& other) = delete;
    timer_awaitable(timer_awaitable&& other) noexcept {
        shared_ = std::move(other.shared_);
        started_ = other.started_;
        other.shared_ = nullptr;
        other.started_ = false;
    };
    timer_awaitable& operator=(timer_awaitable&& other) noexcept {
        reset();
        shared_ = std::move(other.shared_);
        started_ = other.started_;
        other.shared_ = nullptr;
        other.started_ = false;
        return *this;
    };
    
    pollcoro::awaitable_state<void> poll(const pollcoro::waker& w) {
        if (std::chrono::steady_clock::now() >= deadline_) {
            return pollcoro::awaitable_state<void>::ready();
        }
        
        std::lock_guard lock(shared_->mutex);
        shared_->waker = w;
        if (!started_) {
            started_ = true;
            some_cool_timer_api.register_callback([shared = shared_]() {
                std::lock_guard lock(shared->mutex);
                shared->waker.wake();
            });
        }
        
        return pollcoro::awaitable_state<void>::pending();
    }
};

auto sleep_for(std::chrono::milliseconds ms) {
    return timer_awaitable(ms);
}
----

Pay attention to how the waker is stored and accessed, when the `timer_awaitable` is destroyed it unsets the waker so that when the timer fires, the waker is not called. In this example I also use a mutex since awaitables need to be thread-safe. I don't know how the timer api is implemented, however if it is not on the same thread as the awaitable, you need to use a mutex to ensure thread-safety.

== Requirements

* C++17 compiler with coroutine-ts support
* CMake 3.28+ (for modules support)

== License

MIT License — see link:LICENSE[LICENSE] for details.
